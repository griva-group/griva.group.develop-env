# [GGDDEnv] Рабочее окружение
## Описание
Проект предназначен для развертывания тестовго окружения на основе
docker-контейнеров и служит удобным инструментом в обслуживании и разработке
сайтов на локальном рабочем месте. Сам проект разработан для наиболее гибкого
использования и единственным жестко определенным контейнером является
http-сервер - nginx (хотя, при должном навыке, можно это изменить).

Так же, все виртуальные хосты де-факто должны быть именованы как
domain-name.vhost

## Первоначальная установка

##### 1. Клонирование репозитория

##### 2. Создание нового контейнера http-сервера

В корневой папке проекта выполняем следющие комманды:

```bash
docker build --tag=ggenv.nginx ./webserver # Собираем новый образ nginx сервера
docker network create ggenv.network        # Создаем новый ethernet-мост
```

##### 3. Запуск конейнера http-сервера
    
```bash
docker run -d \
    -p 80:80 \
    -v "$(pwd)/projects":/var/www:rw \
    -v "$(pwd)/webserver/logs":/var/log/nginx:rw \
    --network ggenv.network \
    --name ggenv.nginx ggenv.nginx
```

*При создании контейнера на ОС Windows, необходимо ```$(pwd)``` заменить на
```%cd%```, а при использовании PowerShell оболочки, необходимо избавиться от
кавычек и заменить на ```${PWD}```*

##### 4. Проверка работоспособности http-сервера

Переходим по ссылке <http://localhost>, где должны увидеть стандартную
html-заглушку.

## Настройка нового виртуального хоста

##### 1. Клонирование файлов тестовго проекта

##### 2. Подготовка описания нового контейнера http-сервера

Необходимо заменить строки, которые описывают название хоста и его корневую
папку относительно символических ```/var/www/%project_name%/```.

Обращу внимание, что название контейнера php (не включая суффикс ```.php```)
и переменная окружения ```PHP_HOST``` должны быть полностью идентичны.

```yaml
services:
  php:
    container_name: %project_name%.php
      environment:
      - PHP_HOST=%project_name%
      - PHP_DIR=%project_dir_name%
  sql:
    container_name: %project_name%.sql
```

##### 3. Запуск контейнера

Переходим в корень проекта и выполняем следующую команду:

```bash
docker-compose up -d
```

##### 4. Перегрузка конфигурации http-сервера

```bash
docker exec -ti ggenv.nginx nginx -s reload
```

## Список полезных комманд

```bash
# Запуск уже созданного контейнера http-сервера
docker start ggenv.nginx/ggenv.pma

# Принудительная остановка контейнера http-сервера
docker stop -t 5 ggenv.nginx/ggenv.pma

# Перезагрузка конфигурации http-сервера
docker exec -ti ggenv.nginx nginx -s reload

# Войти в интерактивную оболочку контейнера http-сервера
docker exec -i -t ggenv.nginx/ggenv.pma /bin/bash
```

## Создание контейнера с phpMyAdmin панелью

```bash
docker run \
    -p 8081:80 \
    -e PMA_ARBITRARY=1 \
    --network ggenv.network \
    --name ggenv.pma phpmyadmin/phpmyadmin
```

И набор полезных комманд после его создания

```bash
# Запуск уже созданного контейнера с сервером nginx
docker start ggenv.pma

# Принудительная остановка сервера nginx
docker stop -t 5 ggenv.pma

# Перезагрузка сервера
docker restart ggenv.pma
```

## Создание удобной рабочей среды средствами DNS-proxy

Для удобного доступа к проектам убедительно рекомендуется создавать локальные
домены с доменом верхнего уровня *.vhost.

1. Для **\*nix** системам все довольно просто и обкатано: необходимо установить
программу dnsmasq и настроить по
    данной инструкции
    - **macOS** - https://gist.github.com/ogrrd/5831371
    - **Linux** - *еще не найдено*
2. Для **Windows** - https://github.com/stackia/DNSAgent 

## Возможные проблемы

В случае отключения сервиса docker или его непредвиденного завершения скрипты
плавного отключения контейнеров не отрабатывают. Из-за этого контейнер
http-сервера не может стратовать в последствии, потому что пытается пропинговать
несуществующие сокеты. Что бы решить возникшую ситуацию - удалите автоматически-
сгенерированные файлы nginx-конфигурации
(```/var/www/%project_name%/env/php/etc/live.nginx.conf```).














